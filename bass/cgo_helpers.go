// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 03 Oct 2021 20:25:20 CEST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package bass

/*
#include "../include/bass.h"
#include "../include/bassenc.h"
#include "../include/bassenc_mp3.h"
#include "../include/bassmix.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocBassDeviceinfoMemory allocates memory for type C.BASS_DEVICEINFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDeviceinfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDeviceinfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDeviceinfoValue = unsafe.Sizeof([1]C.BASS_DEVICEINFO{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDeviceinfo) Ref() *C.BASS_DEVICEINFO {
	if x == nil {
		return nil
	}
	return x.reff9f2a250
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDeviceinfo) Free() {
	if x != nil && x.allocsf9f2a250 != nil {
		x.allocsf9f2a250.(*cgoAllocMap).Free()
		x.reff9f2a250 = nil
	}
}

// NewBassDeviceinfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDeviceinfoRef(ref unsafe.Pointer) *BassDeviceinfo {
	if ref == nil {
		return nil
	}
	obj := new(BassDeviceinfo)
	obj.reff9f2a250 = (*C.BASS_DEVICEINFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDeviceinfo) PassRef() (*C.BASS_DEVICEINFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff9f2a250 != nil {
		return x.reff9f2a250, nil
	}
	memf9f2a250 := allocBassDeviceinfoMemory(1)
	reff9f2a250 := (*C.BASS_DEVICEINFO)(memf9f2a250)
	allocsf9f2a250 := new(cgoAllocMap)
	allocsf9f2a250.Add(memf9f2a250)

	var cname_allocs *cgoAllocMap
	reff9f2a250.name, cname_allocs = unpackPCharString(x.Name)
	allocsf9f2a250.Borrow(cname_allocs)

	var cdriver_allocs *cgoAllocMap
	reff9f2a250.driver, cdriver_allocs = unpackPCharString(x.Driver)
	allocsf9f2a250.Borrow(cdriver_allocs)

	var cflags_allocs *cgoAllocMap
	reff9f2a250.flags, cflags_allocs = (C.DWORD)(x.Flags), cgoAllocsUnknown
	allocsf9f2a250.Borrow(cflags_allocs)

	x.reff9f2a250 = reff9f2a250
	x.allocsf9f2a250 = allocsf9f2a250
	return reff9f2a250, allocsf9f2a250

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDeviceinfo) PassValue() (C.BASS_DEVICEINFO, *cgoAllocMap) {
	if x.reff9f2a250 != nil {
		return *x.reff9f2a250, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDeviceinfo) Deref() {
	if x.reff9f2a250 == nil {
		return
	}
	x.Name = packPCharString(x.reff9f2a250.name)
	x.Driver = packPCharString(x.reff9f2a250.driver)
	x.Flags = (uint32)(x.reff9f2a250.flags)
}

// allocBassInfoMemory allocates memory for type C.BASS_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassInfoValue = unsafe.Sizeof([1]C.BASS_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassInfo) Ref() *C.BASS_INFO {
	if x == nil {
		return nil
	}
	return x.refd662fca
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassInfo) Free() {
	if x != nil && x.allocsd662fca != nil {
		x.allocsd662fca.(*cgoAllocMap).Free()
		x.refd662fca = nil
	}
}

// NewBassInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassInfoRef(ref unsafe.Pointer) *BassInfo {
	if ref == nil {
		return nil
	}
	obj := new(BassInfo)
	obj.refd662fca = (*C.BASS_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassInfo) PassRef() (*C.BASS_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd662fca != nil {
		return x.refd662fca, nil
	}
	memd662fca := allocBassInfoMemory(1)
	refd662fca := (*C.BASS_INFO)(memd662fca)
	allocsd662fca := new(cgoAllocMap)
	allocsd662fca.Add(memd662fca)

	var cflags_allocs *cgoAllocMap
	refd662fca.flags, cflags_allocs = (C.DWORD)(x.Flags), cgoAllocsUnknown
	allocsd662fca.Borrow(cflags_allocs)

	var chwsize_allocs *cgoAllocMap
	refd662fca.hwsize, chwsize_allocs = (C.DWORD)(x.Hwsize), cgoAllocsUnknown
	allocsd662fca.Borrow(chwsize_allocs)

	var chwfree_allocs *cgoAllocMap
	refd662fca.hwfree, chwfree_allocs = (C.DWORD)(x.Hwfree), cgoAllocsUnknown
	allocsd662fca.Borrow(chwfree_allocs)

	var cfreesam_allocs *cgoAllocMap
	refd662fca.freesam, cfreesam_allocs = (C.DWORD)(x.Freesam), cgoAllocsUnknown
	allocsd662fca.Borrow(cfreesam_allocs)

	var cfree3d_allocs *cgoAllocMap
	refd662fca.free3d, cfree3d_allocs = (C.DWORD)(x.Free3d), cgoAllocsUnknown
	allocsd662fca.Borrow(cfree3d_allocs)

	var cminrate_allocs *cgoAllocMap
	refd662fca.minrate, cminrate_allocs = (C.DWORD)(x.Minrate), cgoAllocsUnknown
	allocsd662fca.Borrow(cminrate_allocs)

	var cmaxrate_allocs *cgoAllocMap
	refd662fca.maxrate, cmaxrate_allocs = (C.DWORD)(x.Maxrate), cgoAllocsUnknown
	allocsd662fca.Borrow(cmaxrate_allocs)

	var ceax_allocs *cgoAllocMap
	refd662fca.eax, ceax_allocs = (C.BOOL)(x.Eax), cgoAllocsUnknown
	allocsd662fca.Borrow(ceax_allocs)

	var cminbuf_allocs *cgoAllocMap
	refd662fca.minbuf, cminbuf_allocs = (C.DWORD)(x.Minbuf), cgoAllocsUnknown
	allocsd662fca.Borrow(cminbuf_allocs)

	var cdsver_allocs *cgoAllocMap
	refd662fca.dsver, cdsver_allocs = (C.DWORD)(x.Dsver), cgoAllocsUnknown
	allocsd662fca.Borrow(cdsver_allocs)

	var clatency_allocs *cgoAllocMap
	refd662fca.latency, clatency_allocs = (C.DWORD)(x.Latency), cgoAllocsUnknown
	allocsd662fca.Borrow(clatency_allocs)

	var cinitflags_allocs *cgoAllocMap
	refd662fca.initflags, cinitflags_allocs = (C.DWORD)(x.Initflags), cgoAllocsUnknown
	allocsd662fca.Borrow(cinitflags_allocs)

	var cspeakers_allocs *cgoAllocMap
	refd662fca.speakers, cspeakers_allocs = (C.DWORD)(x.Speakers), cgoAllocsUnknown
	allocsd662fca.Borrow(cspeakers_allocs)

	var cfreq_allocs *cgoAllocMap
	refd662fca.freq, cfreq_allocs = (C.DWORD)(x.Freq), cgoAllocsUnknown
	allocsd662fca.Borrow(cfreq_allocs)

	x.refd662fca = refd662fca
	x.allocsd662fca = allocsd662fca
	return refd662fca, allocsd662fca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassInfo) PassValue() (C.BASS_INFO, *cgoAllocMap) {
	if x.refd662fca != nil {
		return *x.refd662fca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassInfo) Deref() {
	if x.refd662fca == nil {
		return
	}
	x.Flags = (uint32)(x.refd662fca.flags)
	x.Hwsize = (uint32)(x.refd662fca.hwsize)
	x.Hwfree = (uint32)(x.refd662fca.hwfree)
	x.Freesam = (uint32)(x.refd662fca.freesam)
	x.Free3d = (uint32)(x.refd662fca.free3d)
	x.Minrate = (uint32)(x.refd662fca.minrate)
	x.Maxrate = (uint32)(x.refd662fca.maxrate)
	x.Eax = (int32)(x.refd662fca.eax)
	x.Minbuf = (uint32)(x.refd662fca.minbuf)
	x.Dsver = (uint32)(x.refd662fca.dsver)
	x.Latency = (uint32)(x.refd662fca.latency)
	x.Initflags = (uint32)(x.refd662fca.initflags)
	x.Speakers = (uint32)(x.refd662fca.speakers)
	x.Freq = (uint32)(x.refd662fca.freq)
}

// allocBassRecordinfoMemory allocates memory for type C.BASS_RECORDINFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassRecordinfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassRecordinfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassRecordinfoValue = unsafe.Sizeof([1]C.BASS_RECORDINFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassRecordinfo) Ref() *C.BASS_RECORDINFO {
	if x == nil {
		return nil
	}
	return x.ref7123a104
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassRecordinfo) Free() {
	if x != nil && x.allocs7123a104 != nil {
		x.allocs7123a104.(*cgoAllocMap).Free()
		x.ref7123a104 = nil
	}
}

// NewBassRecordinfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassRecordinfoRef(ref unsafe.Pointer) *BassRecordinfo {
	if ref == nil {
		return nil
	}
	obj := new(BassRecordinfo)
	obj.ref7123a104 = (*C.BASS_RECORDINFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassRecordinfo) PassRef() (*C.BASS_RECORDINFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7123a104 != nil {
		return x.ref7123a104, nil
	}
	mem7123a104 := allocBassRecordinfoMemory(1)
	ref7123a104 := (*C.BASS_RECORDINFO)(mem7123a104)
	allocs7123a104 := new(cgoAllocMap)
	allocs7123a104.Add(mem7123a104)

	var cflags_allocs *cgoAllocMap
	ref7123a104.flags, cflags_allocs = (C.DWORD)(x.Flags), cgoAllocsUnknown
	allocs7123a104.Borrow(cflags_allocs)

	var cformats_allocs *cgoAllocMap
	ref7123a104.formats, cformats_allocs = (C.DWORD)(x.Formats), cgoAllocsUnknown
	allocs7123a104.Borrow(cformats_allocs)

	var cinputs_allocs *cgoAllocMap
	ref7123a104.inputs, cinputs_allocs = (C.DWORD)(x.Inputs), cgoAllocsUnknown
	allocs7123a104.Borrow(cinputs_allocs)

	var csinglein_allocs *cgoAllocMap
	ref7123a104.singlein, csinglein_allocs = (C.BOOL)(x.Singlein), cgoAllocsUnknown
	allocs7123a104.Borrow(csinglein_allocs)

	var cfreq_allocs *cgoAllocMap
	ref7123a104.freq, cfreq_allocs = (C.DWORD)(x.Freq), cgoAllocsUnknown
	allocs7123a104.Borrow(cfreq_allocs)

	x.ref7123a104 = ref7123a104
	x.allocs7123a104 = allocs7123a104
	return ref7123a104, allocs7123a104

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassRecordinfo) PassValue() (C.BASS_RECORDINFO, *cgoAllocMap) {
	if x.ref7123a104 != nil {
		return *x.ref7123a104, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassRecordinfo) Deref() {
	if x.ref7123a104 == nil {
		return
	}
	x.Flags = (uint32)(x.ref7123a104.flags)
	x.Formats = (uint32)(x.ref7123a104.formats)
	x.Inputs = (uint32)(x.ref7123a104.inputs)
	x.Singlein = (int32)(x.ref7123a104.singlein)
	x.Freq = (uint32)(x.ref7123a104.freq)
}

// allocBassSampleMemory allocates memory for type C.BASS_SAMPLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassSampleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassSampleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassSampleValue = unsafe.Sizeof([1]C.BASS_SAMPLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassSample) Ref() *C.BASS_SAMPLE {
	if x == nil {
		return nil
	}
	return x.ref61017d72
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassSample) Free() {
	if x != nil && x.allocs61017d72 != nil {
		x.allocs61017d72.(*cgoAllocMap).Free()
		x.ref61017d72 = nil
	}
}

// NewBassSampleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassSampleRef(ref unsafe.Pointer) *BassSample {
	if ref == nil {
		return nil
	}
	obj := new(BassSample)
	obj.ref61017d72 = (*C.BASS_SAMPLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassSample) PassRef() (*C.BASS_SAMPLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61017d72 != nil {
		return x.ref61017d72, nil
	}
	mem61017d72 := allocBassSampleMemory(1)
	ref61017d72 := (*C.BASS_SAMPLE)(mem61017d72)
	allocs61017d72 := new(cgoAllocMap)
	allocs61017d72.Add(mem61017d72)

	var cfreq_allocs *cgoAllocMap
	ref61017d72.freq, cfreq_allocs = (C.DWORD)(x.Freq), cgoAllocsUnknown
	allocs61017d72.Borrow(cfreq_allocs)

	var cvolume_allocs *cgoAllocMap
	ref61017d72.volume, cvolume_allocs = (C.float)(x.Volume), cgoAllocsUnknown
	allocs61017d72.Borrow(cvolume_allocs)

	var cpan_allocs *cgoAllocMap
	ref61017d72.pan, cpan_allocs = (C.float)(x.Pan), cgoAllocsUnknown
	allocs61017d72.Borrow(cpan_allocs)

	var cflags_allocs *cgoAllocMap
	ref61017d72.flags, cflags_allocs = (C.DWORD)(x.Flags), cgoAllocsUnknown
	allocs61017d72.Borrow(cflags_allocs)

	var clength_allocs *cgoAllocMap
	ref61017d72.length, clength_allocs = (C.DWORD)(x.Length), cgoAllocsUnknown
	allocs61017d72.Borrow(clength_allocs)

	var cmax_allocs *cgoAllocMap
	ref61017d72.max, cmax_allocs = (C.DWORD)(x.Max), cgoAllocsUnknown
	allocs61017d72.Borrow(cmax_allocs)

	var corigres_allocs *cgoAllocMap
	ref61017d72.origres, corigres_allocs = (C.DWORD)(x.Origres), cgoAllocsUnknown
	allocs61017d72.Borrow(corigres_allocs)

	var cchans_allocs *cgoAllocMap
	ref61017d72.chans, cchans_allocs = (C.DWORD)(x.Chans), cgoAllocsUnknown
	allocs61017d72.Borrow(cchans_allocs)

	var cmingap_allocs *cgoAllocMap
	ref61017d72.mingap, cmingap_allocs = (C.DWORD)(x.Mingap), cgoAllocsUnknown
	allocs61017d72.Borrow(cmingap_allocs)

	var cmode3d_allocs *cgoAllocMap
	ref61017d72.mode3d, cmode3d_allocs = (C.DWORD)(x.Mode3d), cgoAllocsUnknown
	allocs61017d72.Borrow(cmode3d_allocs)

	var cmindist_allocs *cgoAllocMap
	ref61017d72.mindist, cmindist_allocs = (C.float)(x.Mindist), cgoAllocsUnknown
	allocs61017d72.Borrow(cmindist_allocs)

	var cmaxdist_allocs *cgoAllocMap
	ref61017d72.maxdist, cmaxdist_allocs = (C.float)(x.Maxdist), cgoAllocsUnknown
	allocs61017d72.Borrow(cmaxdist_allocs)

	var ciangle_allocs *cgoAllocMap
	ref61017d72.iangle, ciangle_allocs = (C.DWORD)(x.Iangle), cgoAllocsUnknown
	allocs61017d72.Borrow(ciangle_allocs)

	var coangle_allocs *cgoAllocMap
	ref61017d72.oangle, coangle_allocs = (C.DWORD)(x.Oangle), cgoAllocsUnknown
	allocs61017d72.Borrow(coangle_allocs)

	var coutvol_allocs *cgoAllocMap
	ref61017d72.outvol, coutvol_allocs = (C.float)(x.Outvol), cgoAllocsUnknown
	allocs61017d72.Borrow(coutvol_allocs)

	var cvam_allocs *cgoAllocMap
	ref61017d72.vam, cvam_allocs = (C.DWORD)(x.Vam), cgoAllocsUnknown
	allocs61017d72.Borrow(cvam_allocs)

	var cpriority_allocs *cgoAllocMap
	ref61017d72.priority, cpriority_allocs = (C.DWORD)(x.Priority), cgoAllocsUnknown
	allocs61017d72.Borrow(cpriority_allocs)

	x.ref61017d72 = ref61017d72
	x.allocs61017d72 = allocs61017d72
	return ref61017d72, allocs61017d72

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassSample) PassValue() (C.BASS_SAMPLE, *cgoAllocMap) {
	if x.ref61017d72 != nil {
		return *x.ref61017d72, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassSample) Deref() {
	if x.ref61017d72 == nil {
		return
	}
	x.Freq = (uint32)(x.ref61017d72.freq)
	x.Volume = (float32)(x.ref61017d72.volume)
	x.Pan = (float32)(x.ref61017d72.pan)
	x.Flags = (uint32)(x.ref61017d72.flags)
	x.Length = (uint32)(x.ref61017d72.length)
	x.Max = (uint32)(x.ref61017d72.max)
	x.Origres = (uint32)(x.ref61017d72.origres)
	x.Chans = (uint32)(x.ref61017d72.chans)
	x.Mingap = (uint32)(x.ref61017d72.mingap)
	x.Mode3d = (uint32)(x.ref61017d72.mode3d)
	x.Mindist = (float32)(x.ref61017d72.mindist)
	x.Maxdist = (float32)(x.ref61017d72.maxdist)
	x.Iangle = (uint32)(x.ref61017d72.iangle)
	x.Oangle = (uint32)(x.ref61017d72.oangle)
	x.Outvol = (float32)(x.ref61017d72.outvol)
	x.Vam = (uint32)(x.ref61017d72.vam)
	x.Priority = (uint32)(x.ref61017d72.priority)
}

// allocBassChannelinfoMemory allocates memory for type C.BASS_CHANNELINFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassChannelinfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassChannelinfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassChannelinfoValue = unsafe.Sizeof([1]C.BASS_CHANNELINFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassChannelinfo) Ref() *C.BASS_CHANNELINFO {
	if x == nil {
		return nil
	}
	return x.refaa6394b0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassChannelinfo) Free() {
	if x != nil && x.allocsaa6394b0 != nil {
		x.allocsaa6394b0.(*cgoAllocMap).Free()
		x.refaa6394b0 = nil
	}
}

// NewBassChannelinfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassChannelinfoRef(ref unsafe.Pointer) *BassChannelinfo {
	if ref == nil {
		return nil
	}
	obj := new(BassChannelinfo)
	obj.refaa6394b0 = (*C.BASS_CHANNELINFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassChannelinfo) PassRef() (*C.BASS_CHANNELINFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa6394b0 != nil {
		return x.refaa6394b0, nil
	}
	memaa6394b0 := allocBassChannelinfoMemory(1)
	refaa6394b0 := (*C.BASS_CHANNELINFO)(memaa6394b0)
	allocsaa6394b0 := new(cgoAllocMap)
	allocsaa6394b0.Add(memaa6394b0)

	var cfreq_allocs *cgoAllocMap
	refaa6394b0.freq, cfreq_allocs = (C.DWORD)(x.Freq), cgoAllocsUnknown
	allocsaa6394b0.Borrow(cfreq_allocs)

	var cchans_allocs *cgoAllocMap
	refaa6394b0.chans, cchans_allocs = (C.DWORD)(x.Chans), cgoAllocsUnknown
	allocsaa6394b0.Borrow(cchans_allocs)

	var cflags_allocs *cgoAllocMap
	refaa6394b0.flags, cflags_allocs = (C.DWORD)(x.Flags), cgoAllocsUnknown
	allocsaa6394b0.Borrow(cflags_allocs)

	var cctype_allocs *cgoAllocMap
	refaa6394b0.ctype, cctype_allocs = (C.DWORD)(x.Ctype), cgoAllocsUnknown
	allocsaa6394b0.Borrow(cctype_allocs)

	var corigres_allocs *cgoAllocMap
	refaa6394b0.origres, corigres_allocs = (C.DWORD)(x.Origres), cgoAllocsUnknown
	allocsaa6394b0.Borrow(corigres_allocs)

	var cplugin_allocs *cgoAllocMap
	refaa6394b0.plugin, cplugin_allocs = (C.HPLUGIN)(x.Plugin), cgoAllocsUnknown
	allocsaa6394b0.Borrow(cplugin_allocs)

	var csample_allocs *cgoAllocMap
	refaa6394b0.sample, csample_allocs = (C.HSAMPLE)(x.Sample), cgoAllocsUnknown
	allocsaa6394b0.Borrow(csample_allocs)

	var cfilename_allocs *cgoAllocMap
	refaa6394b0.filename, cfilename_allocs = unpackPCharString(x.Filename)
	allocsaa6394b0.Borrow(cfilename_allocs)

	x.refaa6394b0 = refaa6394b0
	x.allocsaa6394b0 = allocsaa6394b0
	return refaa6394b0, allocsaa6394b0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassChannelinfo) PassValue() (C.BASS_CHANNELINFO, *cgoAllocMap) {
	if x.refaa6394b0 != nil {
		return *x.refaa6394b0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassChannelinfo) Deref() {
	if x.refaa6394b0 == nil {
		return
	}
	x.Freq = (uint32)(x.refaa6394b0.freq)
	x.Chans = (uint32)(x.refaa6394b0.chans)
	x.Flags = (uint32)(x.refaa6394b0.flags)
	x.Ctype = (uint32)(x.refaa6394b0.ctype)
	x.Origres = (uint32)(x.refaa6394b0.origres)
	x.Plugin = (uint32)(x.refaa6394b0.plugin)
	x.Sample = (uint32)(x.refaa6394b0.sample)
	x.Filename = packPCharString(x.refaa6394b0.filename)
}

// allocBassPluginformMemory allocates memory for type C.BASS_PLUGINFORM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassPluginformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassPluginformValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassPluginformValue = unsafe.Sizeof([1]C.BASS_PLUGINFORM{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassPluginform) Ref() *C.BASS_PLUGINFORM {
	if x == nil {
		return nil
	}
	return x.refeaee9748
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassPluginform) Free() {
	if x != nil && x.allocseaee9748 != nil {
		x.allocseaee9748.(*cgoAllocMap).Free()
		x.refeaee9748 = nil
	}
}

// NewBassPluginformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassPluginformRef(ref unsafe.Pointer) *BassPluginform {
	if ref == nil {
		return nil
	}
	obj := new(BassPluginform)
	obj.refeaee9748 = (*C.BASS_PLUGINFORM)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassPluginform) PassRef() (*C.BASS_PLUGINFORM, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaee9748 != nil {
		return x.refeaee9748, nil
	}
	memeaee9748 := allocBassPluginformMemory(1)
	refeaee9748 := (*C.BASS_PLUGINFORM)(memeaee9748)
	allocseaee9748 := new(cgoAllocMap)
	allocseaee9748.Add(memeaee9748)

	var cctype_allocs *cgoAllocMap
	refeaee9748.ctype, cctype_allocs = (C.DWORD)(x.Ctype), cgoAllocsUnknown
	allocseaee9748.Borrow(cctype_allocs)

	var cname_allocs *cgoAllocMap
	refeaee9748.name, cname_allocs = unpackPCharString(x.Name)
	allocseaee9748.Borrow(cname_allocs)

	var cexts_allocs *cgoAllocMap
	refeaee9748.exts, cexts_allocs = unpackPCharString(x.Exts)
	allocseaee9748.Borrow(cexts_allocs)

	x.refeaee9748 = refeaee9748
	x.allocseaee9748 = allocseaee9748
	return refeaee9748, allocseaee9748

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassPluginform) PassValue() (C.BASS_PLUGINFORM, *cgoAllocMap) {
	if x.refeaee9748 != nil {
		return *x.refeaee9748, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassPluginform) Deref() {
	if x.refeaee9748 == nil {
		return
	}
	x.Ctype = (uint32)(x.refeaee9748.ctype)
	x.Name = packPCharString(x.refeaee9748.name)
	x.Exts = packPCharString(x.refeaee9748.exts)
}

// allocBassPlugininfoMemory allocates memory for type C.BASS_PLUGININFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassPlugininfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassPlugininfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassPlugininfoValue = unsafe.Sizeof([1]C.BASS_PLUGININFO{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSBassPluginform transforms a sliced Go data structure into plain C format.
func unpackSBassPluginform(x []BassPluginform) (unpacked *C.BASS_PLUGINFORM, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBassPluginformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BASS_PLUGINFORM)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BASS_PLUGINFORM)(h.Data)
	return
}

// packSBassPluginform reads sliced Go data structure out from plain C format.
func packSBassPluginform(v []BassPluginform, ptr0 *C.BASS_PLUGINFORM) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBassPluginformValue]C.BASS_PLUGINFORM)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBassPluginformRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassPlugininfo) Ref() *C.BASS_PLUGININFO {
	if x == nil {
		return nil
	}
	return x.ref73ef5b50
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassPlugininfo) Free() {
	if x != nil && x.allocs73ef5b50 != nil {
		x.allocs73ef5b50.(*cgoAllocMap).Free()
		x.ref73ef5b50 = nil
	}
}

// NewBassPlugininfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassPlugininfoRef(ref unsafe.Pointer) *BassPlugininfo {
	if ref == nil {
		return nil
	}
	obj := new(BassPlugininfo)
	obj.ref73ef5b50 = (*C.BASS_PLUGININFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassPlugininfo) PassRef() (*C.BASS_PLUGININFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73ef5b50 != nil {
		return x.ref73ef5b50, nil
	}
	mem73ef5b50 := allocBassPlugininfoMemory(1)
	ref73ef5b50 := (*C.BASS_PLUGININFO)(mem73ef5b50)
	allocs73ef5b50 := new(cgoAllocMap)
	allocs73ef5b50.Add(mem73ef5b50)

	var cversion_allocs *cgoAllocMap
	ref73ef5b50.version, cversion_allocs = (C.DWORD)(x.Version), cgoAllocsUnknown
	allocs73ef5b50.Borrow(cversion_allocs)

	var cformatc_allocs *cgoAllocMap
	ref73ef5b50.formatc, cformatc_allocs = (C.DWORD)(x.Formatc), cgoAllocsUnknown
	allocs73ef5b50.Borrow(cformatc_allocs)

	var cformats_allocs *cgoAllocMap
	ref73ef5b50.formats, cformats_allocs = unpackSBassPluginform(x.Formats)
	allocs73ef5b50.Borrow(cformats_allocs)

	x.ref73ef5b50 = ref73ef5b50
	x.allocs73ef5b50 = allocs73ef5b50
	return ref73ef5b50, allocs73ef5b50

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassPlugininfo) PassValue() (C.BASS_PLUGININFO, *cgoAllocMap) {
	if x.ref73ef5b50 != nil {
		return *x.ref73ef5b50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassPlugininfo) Deref() {
	if x.ref73ef5b50 == nil {
		return
	}
	x.Version = (uint32)(x.ref73ef5b50.version)
	x.Formatc = (uint32)(x.ref73ef5b50.formatc)
	packSBassPluginform(x.Formats, x.ref73ef5b50.formats)
}

// allocBass3dvectorMemory allocates memory for type C.BASS_3DVECTOR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBass3dvectorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBass3dvectorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBass3dvectorValue = unsafe.Sizeof([1]C.BASS_3DVECTOR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Bass3dvector) Ref() *C.BASS_3DVECTOR {
	if x == nil {
		return nil
	}
	return x.ref86a5babe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Bass3dvector) Free() {
	if x != nil && x.allocs86a5babe != nil {
		x.allocs86a5babe.(*cgoAllocMap).Free()
		x.ref86a5babe = nil
	}
}

// NewBass3dvectorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBass3dvectorRef(ref unsafe.Pointer) *Bass3dvector {
	if ref == nil {
		return nil
	}
	obj := new(Bass3dvector)
	obj.ref86a5babe = (*C.BASS_3DVECTOR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Bass3dvector) PassRef() (*C.BASS_3DVECTOR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86a5babe != nil {
		return x.ref86a5babe, nil
	}
	mem86a5babe := allocBass3dvectorMemory(1)
	ref86a5babe := (*C.BASS_3DVECTOR)(mem86a5babe)
	allocs86a5babe := new(cgoAllocMap)
	allocs86a5babe.Add(mem86a5babe)

	var cx_allocs *cgoAllocMap
	ref86a5babe.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs86a5babe.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref86a5babe.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs86a5babe.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref86a5babe.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocs86a5babe.Borrow(cz_allocs)

	x.ref86a5babe = ref86a5babe
	x.allocs86a5babe = allocs86a5babe
	return ref86a5babe, allocs86a5babe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Bass3dvector) PassValue() (C.BASS_3DVECTOR, *cgoAllocMap) {
	if x.ref86a5babe != nil {
		return *x.ref86a5babe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Bass3dvector) Deref() {
	if x.ref86a5babe == nil {
		return
	}
	x.X = (float32)(x.ref86a5babe.x)
	x.Y = (float32)(x.ref86a5babe.y)
	x.Z = (float32)(x.ref86a5babe.z)
}

func (x Streamproc) PassRef() (ref *C.STREAMPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if streamprocC741188FFunc == nil {
		streamprocC741188FFunc = x
	}
	return (*C.STREAMPROC)(C.STREAMPROC_c741188f), nil
}

func NewStreamprocRef(ref unsafe.Pointer) *Streamproc {
	return (*Streamproc)(ref)
}

//export streamprocC741188F
func streamprocC741188F(chandle C.HSTREAM, cbuffer unsafe.Pointer, clength C.DWORD, cuser unsafe.Pointer) C.DWORD {
	if streamprocC741188FFunc != nil {
		handlec741188f := (uint32)(chandle)
		bufferc741188f := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		lengthc741188f := (uint32)(clength)
		userc741188f := (unsafe.Pointer)(unsafe.Pointer(cuser))
		retc741188f := streamprocC741188FFunc(handlec741188f, bufferc741188f, lengthc741188f, userc741188f)
		ret, _ := (C.DWORD)(retc741188f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var streamprocC741188FFunc Streamproc

func (x Filecloseproc) PassRef() (ref *C.FILECLOSEPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if filecloseproc16713455Func == nil {
		filecloseproc16713455Func = x
	}
	return (*C.FILECLOSEPROC)(C.FILECLOSEPROC_16713455), nil
}

func NewFilecloseprocRef(ref unsafe.Pointer) *Filecloseproc {
	return (*Filecloseproc)(ref)
}

//export filecloseproc16713455
func filecloseproc16713455(cuser unsafe.Pointer) {
	if filecloseproc16713455Func != nil {
		user16713455 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		filecloseproc16713455Func(user16713455)
		return
	}
	panic("callback func has not been set (race?)")
}

var filecloseproc16713455Func Filecloseproc

func (x Filelenproc) PassRef() (ref *C.FILELENPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if filelenproc69F2A6D6Func == nil {
		filelenproc69F2A6D6Func = x
	}
	return (*C.FILELENPROC)(C.FILELENPROC_69f2a6d6), nil
}

func NewFilelenprocRef(ref unsafe.Pointer) *Filelenproc {
	return (*Filelenproc)(ref)
}

//export filelenproc69F2A6D6
func filelenproc69F2A6D6(cuser unsafe.Pointer) C.QWORD {
	if filelenproc69F2A6D6Func != nil {
		user69f2a6d6 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		ret69f2a6d6 := filelenproc69F2A6D6Func(user69f2a6d6)
		ret, _ := (C.QWORD)(ret69f2a6d6), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var filelenproc69F2A6D6Func Filelenproc

func (x Filereadproc) PassRef() (ref *C.FILEREADPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if filereadproc4D4B6DCAFunc == nil {
		filereadproc4D4B6DCAFunc = x
	}
	return (*C.FILEREADPROC)(C.FILEREADPROC_4d4b6dca), nil
}

func NewFilereadprocRef(ref unsafe.Pointer) *Filereadproc {
	return (*Filereadproc)(ref)
}

//export filereadproc4D4B6DCA
func filereadproc4D4B6DCA(cbuffer unsafe.Pointer, clength C.DWORD, cuser unsafe.Pointer) C.DWORD {
	if filereadproc4D4B6DCAFunc != nil {
		buffer4d4b6dca := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		length4d4b6dca := (uint32)(clength)
		user4d4b6dca := (unsafe.Pointer)(unsafe.Pointer(cuser))
		ret4d4b6dca := filereadproc4D4B6DCAFunc(buffer4d4b6dca, length4d4b6dca, user4d4b6dca)
		ret, _ := (C.DWORD)(ret4d4b6dca), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var filereadproc4D4B6DCAFunc Filereadproc

func (x Fileseekproc) PassRef() (ref *C.FILESEEKPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fileseekproc9820B893Func == nil {
		fileseekproc9820B893Func = x
	}
	return (*C.FILESEEKPROC)(C.FILESEEKPROC_9820b893), nil
}

func NewFileseekprocRef(ref unsafe.Pointer) *Fileseekproc {
	return (*Fileseekproc)(ref)
}

//export fileseekproc9820B893
func fileseekproc9820B893(coffset C.QWORD, cuser unsafe.Pointer) C.BOOL {
	if fileseekproc9820B893Func != nil {
		offset9820b893 := (uint64)(coffset)
		user9820b893 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		ret9820b893 := fileseekproc9820B893Func(offset9820b893, user9820b893)
		ret, _ := (C.BOOL)(ret9820b893), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fileseekproc9820B893Func Fileseekproc

// allocBassFileprocsMemory allocates memory for type C.BASS_FILEPROCS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassFileprocsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassFileprocsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassFileprocsValue = unsafe.Sizeof([1]C.BASS_FILEPROCS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassFileprocs) Ref() *C.BASS_FILEPROCS {
	if x == nil {
		return nil
	}
	return x.refbf5215a7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassFileprocs) Free() {
	if x != nil && x.allocsbf5215a7 != nil {
		x.allocsbf5215a7.(*cgoAllocMap).Free()
		x.refbf5215a7 = nil
	}
}

// NewBassFileprocsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassFileprocsRef(ref unsafe.Pointer) *BassFileprocs {
	if ref == nil {
		return nil
	}
	obj := new(BassFileprocs)
	obj.refbf5215a7 = (*C.BASS_FILEPROCS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassFileprocs) PassRef() (*C.BASS_FILEPROCS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbf5215a7 != nil {
		return x.refbf5215a7, nil
	}
	membf5215a7 := allocBassFileprocsMemory(1)
	refbf5215a7 := (*C.BASS_FILEPROCS)(membf5215a7)
	allocsbf5215a7 := new(cgoAllocMap)
	allocsbf5215a7.Add(membf5215a7)

	var cclose_allocs *cgoAllocMap
	refbf5215a7.close, cclose_allocs = x.Close.PassRef()
	allocsbf5215a7.Borrow(cclose_allocs)

	var clength_allocs *cgoAllocMap
	refbf5215a7.length, clength_allocs = x.Length.PassRef()
	allocsbf5215a7.Borrow(clength_allocs)

	var cread_allocs *cgoAllocMap
	refbf5215a7.read, cread_allocs = x.Read.PassRef()
	allocsbf5215a7.Borrow(cread_allocs)

	var cseek_allocs *cgoAllocMap
	refbf5215a7.seek, cseek_allocs = x.Seek.PassRef()
	allocsbf5215a7.Borrow(cseek_allocs)

	x.refbf5215a7 = refbf5215a7
	x.allocsbf5215a7 = allocsbf5215a7
	return refbf5215a7, allocsbf5215a7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassFileprocs) PassValue() (C.BASS_FILEPROCS, *cgoAllocMap) {
	if x.refbf5215a7 != nil {
		return *x.refbf5215a7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassFileprocs) Deref() {
	if x.refbf5215a7 == nil {
		return
	}
	x.Close = *NewFilecloseprocRef(unsafe.Pointer(x.refbf5215a7.close))
	x.Length = *NewFilelenprocRef(unsafe.Pointer(x.refbf5215a7.length))
	x.Read = *NewFilereadprocRef(unsafe.Pointer(x.refbf5215a7.read))
	x.Seek = *NewFileseekprocRef(unsafe.Pointer(x.refbf5215a7.seek))
}

func (x Downloadproc) PassRef() (ref *C.DOWNLOADPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if downloadprocD99FA183Func == nil {
		downloadprocD99FA183Func = x
	}
	return (*C.DOWNLOADPROC)(C.DOWNLOADPROC_d99fa183), nil
}

func NewDownloadprocRef(ref unsafe.Pointer) *Downloadproc {
	return (*Downloadproc)(ref)
}

//export downloadprocD99FA183
func downloadprocD99FA183(cbuffer unsafe.Pointer, clength C.DWORD, cuser unsafe.Pointer) {
	if downloadprocD99FA183Func != nil {
		bufferd99fa183 := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		lengthd99fa183 := (uint32)(clength)
		userd99fa183 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		downloadprocD99FA183Func(bufferd99fa183, lengthd99fa183, userd99fa183)
		return
	}
	panic("callback func has not been set (race?)")
}

var downloadprocD99FA183Func Downloadproc

func (x Syncproc) PassRef() (ref *C.SYNCPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if syncproc1EC67831Func == nil {
		syncproc1EC67831Func = x
	}
	return (*C.SYNCPROC)(C.SYNCPROC_1ec67831), nil
}

func NewSyncprocRef(ref unsafe.Pointer) *Syncproc {
	return (*Syncproc)(ref)
}

//export syncproc1EC67831
func syncproc1EC67831(chandle C.HSYNC, cchannel C.DWORD, cdata C.DWORD, cuser unsafe.Pointer) {
	if syncproc1EC67831Func != nil {
		handle1ec67831 := (uint32)(chandle)
		channel1ec67831 := (uint32)(cchannel)
		data1ec67831 := (uint32)(cdata)
		user1ec67831 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		syncproc1EC67831Func(handle1ec67831, channel1ec67831, data1ec67831, user1ec67831)
		return
	}
	panic("callback func has not been set (race?)")
}

var syncproc1EC67831Func Syncproc

func (x Dspproc) PassRef() (ref *C.DSPPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dspprocA3208D1AFunc == nil {
		dspprocA3208D1AFunc = x
	}
	return (*C.DSPPROC)(C.DSPPROC_a3208d1a), nil
}

func NewDspprocRef(ref unsafe.Pointer) *Dspproc {
	return (*Dspproc)(ref)
}

//export dspprocA3208D1A
func dspprocA3208D1A(chandle C.HDSP, cchannel C.DWORD, cbuffer unsafe.Pointer, clength C.DWORD, cuser unsafe.Pointer) {
	if dspprocA3208D1AFunc != nil {
		handlea3208d1a := (uint32)(chandle)
		channela3208d1a := (uint32)(cchannel)
		buffera3208d1a := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		lengtha3208d1a := (uint32)(clength)
		usera3208d1a := (unsafe.Pointer)(unsafe.Pointer(cuser))
		dspprocA3208D1AFunc(handlea3208d1a, channela3208d1a, buffera3208d1a, lengtha3208d1a, usera3208d1a)
		return
	}
	panic("callback func has not been set (race?)")
}

var dspprocA3208D1AFunc Dspproc

func (x Recordproc) PassRef() (ref *C.RECORDPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if recordprocF0B593CFunc == nil {
		recordprocF0B593CFunc = x
	}
	return (*C.RECORDPROC)(C.RECORDPROC_f0b593c), nil
}

func NewRecordprocRef(ref unsafe.Pointer) *Recordproc {
	return (*Recordproc)(ref)
}

//export recordprocF0B593C
func recordprocF0B593C(chandle C.HRECORD, cbuffer unsafe.Pointer, clength C.DWORD, cuser unsafe.Pointer) C.BOOL {
	if recordprocF0B593CFunc != nil {
		handlef0b593c := (uint32)(chandle)
		bufferf0b593c := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		lengthf0b593c := (uint32)(clength)
		userf0b593c := (unsafe.Pointer)(unsafe.Pointer(cuser))
		retf0b593c := recordprocF0B593CFunc(handlef0b593c, bufferf0b593c, lengthf0b593c, userf0b593c)
		ret, _ := (C.BOOL)(retf0b593c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var recordprocF0B593CFunc Recordproc

// allocBassDx8ChorusMemory allocates memory for type C.BASS_DX8_CHORUS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8ChorusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8ChorusValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8ChorusValue = unsafe.Sizeof([1]C.BASS_DX8_CHORUS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Chorus) Ref() *C.BASS_DX8_CHORUS {
	if x == nil {
		return nil
	}
	return x.refd83bc0af
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Chorus) Free() {
	if x != nil && x.allocsd83bc0af != nil {
		x.allocsd83bc0af.(*cgoAllocMap).Free()
		x.refd83bc0af = nil
	}
}

// NewBassDx8ChorusRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8ChorusRef(ref unsafe.Pointer) *BassDx8Chorus {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Chorus)
	obj.refd83bc0af = (*C.BASS_DX8_CHORUS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Chorus) PassRef() (*C.BASS_DX8_CHORUS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd83bc0af != nil {
		return x.refd83bc0af, nil
	}
	memd83bc0af := allocBassDx8ChorusMemory(1)
	refd83bc0af := (*C.BASS_DX8_CHORUS)(memd83bc0af)
	allocsd83bc0af := new(cgoAllocMap)
	allocsd83bc0af.Add(memd83bc0af)

	var cfWetDryMix_allocs *cgoAllocMap
	refd83bc0af.fWetDryMix, cfWetDryMix_allocs = (C.float)(x.Fwetdrymix), cgoAllocsUnknown
	allocsd83bc0af.Borrow(cfWetDryMix_allocs)

	var cfDepth_allocs *cgoAllocMap
	refd83bc0af.fDepth, cfDepth_allocs = (C.float)(x.Fdepth), cgoAllocsUnknown
	allocsd83bc0af.Borrow(cfDepth_allocs)

	var cfFeedback_allocs *cgoAllocMap
	refd83bc0af.fFeedback, cfFeedback_allocs = (C.float)(x.Ffeedback), cgoAllocsUnknown
	allocsd83bc0af.Borrow(cfFeedback_allocs)

	var cfFrequency_allocs *cgoAllocMap
	refd83bc0af.fFrequency, cfFrequency_allocs = (C.float)(x.Ffrequency), cgoAllocsUnknown
	allocsd83bc0af.Borrow(cfFrequency_allocs)

	var clWaveform_allocs *cgoAllocMap
	refd83bc0af.lWaveform, clWaveform_allocs = (C.DWORD)(x.Lwaveform), cgoAllocsUnknown
	allocsd83bc0af.Borrow(clWaveform_allocs)

	var cfDelay_allocs *cgoAllocMap
	refd83bc0af.fDelay, cfDelay_allocs = (C.float)(x.Fdelay), cgoAllocsUnknown
	allocsd83bc0af.Borrow(cfDelay_allocs)

	var clPhase_allocs *cgoAllocMap
	refd83bc0af.lPhase, clPhase_allocs = (C.DWORD)(x.Lphase), cgoAllocsUnknown
	allocsd83bc0af.Borrow(clPhase_allocs)

	x.refd83bc0af = refd83bc0af
	x.allocsd83bc0af = allocsd83bc0af
	return refd83bc0af, allocsd83bc0af

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Chorus) PassValue() (C.BASS_DX8_CHORUS, *cgoAllocMap) {
	if x.refd83bc0af != nil {
		return *x.refd83bc0af, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Chorus) Deref() {
	if x.refd83bc0af == nil {
		return
	}
	x.Fwetdrymix = (float32)(x.refd83bc0af.fWetDryMix)
	x.Fdepth = (float32)(x.refd83bc0af.fDepth)
	x.Ffeedback = (float32)(x.refd83bc0af.fFeedback)
	x.Ffrequency = (float32)(x.refd83bc0af.fFrequency)
	x.Lwaveform = (uint32)(x.refd83bc0af.lWaveform)
	x.Fdelay = (float32)(x.refd83bc0af.fDelay)
	x.Lphase = (uint32)(x.refd83bc0af.lPhase)
}

// allocBassDx8CompressorMemory allocates memory for type C.BASS_DX8_COMPRESSOR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8CompressorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8CompressorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8CompressorValue = unsafe.Sizeof([1]C.BASS_DX8_COMPRESSOR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Compressor) Ref() *C.BASS_DX8_COMPRESSOR {
	if x == nil {
		return nil
	}
	return x.ref17e18f61
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Compressor) Free() {
	if x != nil && x.allocs17e18f61 != nil {
		x.allocs17e18f61.(*cgoAllocMap).Free()
		x.ref17e18f61 = nil
	}
}

// NewBassDx8CompressorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8CompressorRef(ref unsafe.Pointer) *BassDx8Compressor {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Compressor)
	obj.ref17e18f61 = (*C.BASS_DX8_COMPRESSOR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Compressor) PassRef() (*C.BASS_DX8_COMPRESSOR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17e18f61 != nil {
		return x.ref17e18f61, nil
	}
	mem17e18f61 := allocBassDx8CompressorMemory(1)
	ref17e18f61 := (*C.BASS_DX8_COMPRESSOR)(mem17e18f61)
	allocs17e18f61 := new(cgoAllocMap)
	allocs17e18f61.Add(mem17e18f61)

	var cfGain_allocs *cgoAllocMap
	ref17e18f61.fGain, cfGain_allocs = (C.float)(x.Fgain), cgoAllocsUnknown
	allocs17e18f61.Borrow(cfGain_allocs)

	var cfAttack_allocs *cgoAllocMap
	ref17e18f61.fAttack, cfAttack_allocs = (C.float)(x.Fattack), cgoAllocsUnknown
	allocs17e18f61.Borrow(cfAttack_allocs)

	var cfRelease_allocs *cgoAllocMap
	ref17e18f61.fRelease, cfRelease_allocs = (C.float)(x.Frelease), cgoAllocsUnknown
	allocs17e18f61.Borrow(cfRelease_allocs)

	var cfThreshold_allocs *cgoAllocMap
	ref17e18f61.fThreshold, cfThreshold_allocs = (C.float)(x.Fthreshold), cgoAllocsUnknown
	allocs17e18f61.Borrow(cfThreshold_allocs)

	var cfRatio_allocs *cgoAllocMap
	ref17e18f61.fRatio, cfRatio_allocs = (C.float)(x.Fratio), cgoAllocsUnknown
	allocs17e18f61.Borrow(cfRatio_allocs)

	var cfPredelay_allocs *cgoAllocMap
	ref17e18f61.fPredelay, cfPredelay_allocs = (C.float)(x.Fpredelay), cgoAllocsUnknown
	allocs17e18f61.Borrow(cfPredelay_allocs)

	x.ref17e18f61 = ref17e18f61
	x.allocs17e18f61 = allocs17e18f61
	return ref17e18f61, allocs17e18f61

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Compressor) PassValue() (C.BASS_DX8_COMPRESSOR, *cgoAllocMap) {
	if x.ref17e18f61 != nil {
		return *x.ref17e18f61, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Compressor) Deref() {
	if x.ref17e18f61 == nil {
		return
	}
	x.Fgain = (float32)(x.ref17e18f61.fGain)
	x.Fattack = (float32)(x.ref17e18f61.fAttack)
	x.Frelease = (float32)(x.ref17e18f61.fRelease)
	x.Fthreshold = (float32)(x.ref17e18f61.fThreshold)
	x.Fratio = (float32)(x.ref17e18f61.fRatio)
	x.Fpredelay = (float32)(x.ref17e18f61.fPredelay)
}

// allocBassDx8DistortionMemory allocates memory for type C.BASS_DX8_DISTORTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8DistortionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8DistortionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8DistortionValue = unsafe.Sizeof([1]C.BASS_DX8_DISTORTION{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Distortion) Ref() *C.BASS_DX8_DISTORTION {
	if x == nil {
		return nil
	}
	return x.refeeb6f21f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Distortion) Free() {
	if x != nil && x.allocseeb6f21f != nil {
		x.allocseeb6f21f.(*cgoAllocMap).Free()
		x.refeeb6f21f = nil
	}
}

// NewBassDx8DistortionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8DistortionRef(ref unsafe.Pointer) *BassDx8Distortion {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Distortion)
	obj.refeeb6f21f = (*C.BASS_DX8_DISTORTION)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Distortion) PassRef() (*C.BASS_DX8_DISTORTION, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeeb6f21f != nil {
		return x.refeeb6f21f, nil
	}
	memeeb6f21f := allocBassDx8DistortionMemory(1)
	refeeb6f21f := (*C.BASS_DX8_DISTORTION)(memeeb6f21f)
	allocseeb6f21f := new(cgoAllocMap)
	allocseeb6f21f.Add(memeeb6f21f)

	var cfGain_allocs *cgoAllocMap
	refeeb6f21f.fGain, cfGain_allocs = (C.float)(x.Fgain), cgoAllocsUnknown
	allocseeb6f21f.Borrow(cfGain_allocs)

	var cfEdge_allocs *cgoAllocMap
	refeeb6f21f.fEdge, cfEdge_allocs = (C.float)(x.Fedge), cgoAllocsUnknown
	allocseeb6f21f.Borrow(cfEdge_allocs)

	var cfPostEQCenterFrequency_allocs *cgoAllocMap
	refeeb6f21f.fPostEQCenterFrequency, cfPostEQCenterFrequency_allocs = (C.float)(x.Fposteqcenterfrequency), cgoAllocsUnknown
	allocseeb6f21f.Borrow(cfPostEQCenterFrequency_allocs)

	var cfPostEQBandwidth_allocs *cgoAllocMap
	refeeb6f21f.fPostEQBandwidth, cfPostEQBandwidth_allocs = (C.float)(x.Fposteqbandwidth), cgoAllocsUnknown
	allocseeb6f21f.Borrow(cfPostEQBandwidth_allocs)

	var cfPreLowpassCutoff_allocs *cgoAllocMap
	refeeb6f21f.fPreLowpassCutoff, cfPreLowpassCutoff_allocs = (C.float)(x.Fprelowpasscutoff), cgoAllocsUnknown
	allocseeb6f21f.Borrow(cfPreLowpassCutoff_allocs)

	x.refeeb6f21f = refeeb6f21f
	x.allocseeb6f21f = allocseeb6f21f
	return refeeb6f21f, allocseeb6f21f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Distortion) PassValue() (C.BASS_DX8_DISTORTION, *cgoAllocMap) {
	if x.refeeb6f21f != nil {
		return *x.refeeb6f21f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Distortion) Deref() {
	if x.refeeb6f21f == nil {
		return
	}
	x.Fgain = (float32)(x.refeeb6f21f.fGain)
	x.Fedge = (float32)(x.refeeb6f21f.fEdge)
	x.Fposteqcenterfrequency = (float32)(x.refeeb6f21f.fPostEQCenterFrequency)
	x.Fposteqbandwidth = (float32)(x.refeeb6f21f.fPostEQBandwidth)
	x.Fprelowpasscutoff = (float32)(x.refeeb6f21f.fPreLowpassCutoff)
}

// allocBassDx8EchoMemory allocates memory for type C.BASS_DX8_ECHO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8EchoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8EchoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8EchoValue = unsafe.Sizeof([1]C.BASS_DX8_ECHO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Echo) Ref() *C.BASS_DX8_ECHO {
	if x == nil {
		return nil
	}
	return x.ref88a525b3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Echo) Free() {
	if x != nil && x.allocs88a525b3 != nil {
		x.allocs88a525b3.(*cgoAllocMap).Free()
		x.ref88a525b3 = nil
	}
}

// NewBassDx8EchoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8EchoRef(ref unsafe.Pointer) *BassDx8Echo {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Echo)
	obj.ref88a525b3 = (*C.BASS_DX8_ECHO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Echo) PassRef() (*C.BASS_DX8_ECHO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref88a525b3 != nil {
		return x.ref88a525b3, nil
	}
	mem88a525b3 := allocBassDx8EchoMemory(1)
	ref88a525b3 := (*C.BASS_DX8_ECHO)(mem88a525b3)
	allocs88a525b3 := new(cgoAllocMap)
	allocs88a525b3.Add(mem88a525b3)

	var cfWetDryMix_allocs *cgoAllocMap
	ref88a525b3.fWetDryMix, cfWetDryMix_allocs = (C.float)(x.Fwetdrymix), cgoAllocsUnknown
	allocs88a525b3.Borrow(cfWetDryMix_allocs)

	var cfFeedback_allocs *cgoAllocMap
	ref88a525b3.fFeedback, cfFeedback_allocs = (C.float)(x.Ffeedback), cgoAllocsUnknown
	allocs88a525b3.Borrow(cfFeedback_allocs)

	var cfLeftDelay_allocs *cgoAllocMap
	ref88a525b3.fLeftDelay, cfLeftDelay_allocs = (C.float)(x.Fleftdelay), cgoAllocsUnknown
	allocs88a525b3.Borrow(cfLeftDelay_allocs)

	var cfRightDelay_allocs *cgoAllocMap
	ref88a525b3.fRightDelay, cfRightDelay_allocs = (C.float)(x.Frightdelay), cgoAllocsUnknown
	allocs88a525b3.Borrow(cfRightDelay_allocs)

	var clPanDelay_allocs *cgoAllocMap
	ref88a525b3.lPanDelay, clPanDelay_allocs = (C.BOOL)(x.Lpandelay), cgoAllocsUnknown
	allocs88a525b3.Borrow(clPanDelay_allocs)

	x.ref88a525b3 = ref88a525b3
	x.allocs88a525b3 = allocs88a525b3
	return ref88a525b3, allocs88a525b3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Echo) PassValue() (C.BASS_DX8_ECHO, *cgoAllocMap) {
	if x.ref88a525b3 != nil {
		return *x.ref88a525b3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Echo) Deref() {
	if x.ref88a525b3 == nil {
		return
	}
	x.Fwetdrymix = (float32)(x.ref88a525b3.fWetDryMix)
	x.Ffeedback = (float32)(x.ref88a525b3.fFeedback)
	x.Fleftdelay = (float32)(x.ref88a525b3.fLeftDelay)
	x.Frightdelay = (float32)(x.ref88a525b3.fRightDelay)
	x.Lpandelay = (int32)(x.ref88a525b3.lPanDelay)
}

// allocBassDx8FlangerMemory allocates memory for type C.BASS_DX8_FLANGER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8FlangerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8FlangerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8FlangerValue = unsafe.Sizeof([1]C.BASS_DX8_FLANGER{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Flanger) Ref() *C.BASS_DX8_FLANGER {
	if x == nil {
		return nil
	}
	return x.ref7ebaa3d2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Flanger) Free() {
	if x != nil && x.allocs7ebaa3d2 != nil {
		x.allocs7ebaa3d2.(*cgoAllocMap).Free()
		x.ref7ebaa3d2 = nil
	}
}

// NewBassDx8FlangerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8FlangerRef(ref unsafe.Pointer) *BassDx8Flanger {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Flanger)
	obj.ref7ebaa3d2 = (*C.BASS_DX8_FLANGER)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Flanger) PassRef() (*C.BASS_DX8_FLANGER, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7ebaa3d2 != nil {
		return x.ref7ebaa3d2, nil
	}
	mem7ebaa3d2 := allocBassDx8FlangerMemory(1)
	ref7ebaa3d2 := (*C.BASS_DX8_FLANGER)(mem7ebaa3d2)
	allocs7ebaa3d2 := new(cgoAllocMap)
	allocs7ebaa3d2.Add(mem7ebaa3d2)

	var cfWetDryMix_allocs *cgoAllocMap
	ref7ebaa3d2.fWetDryMix, cfWetDryMix_allocs = (C.float)(x.Fwetdrymix), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(cfWetDryMix_allocs)

	var cfDepth_allocs *cgoAllocMap
	ref7ebaa3d2.fDepth, cfDepth_allocs = (C.float)(x.Fdepth), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(cfDepth_allocs)

	var cfFeedback_allocs *cgoAllocMap
	ref7ebaa3d2.fFeedback, cfFeedback_allocs = (C.float)(x.Ffeedback), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(cfFeedback_allocs)

	var cfFrequency_allocs *cgoAllocMap
	ref7ebaa3d2.fFrequency, cfFrequency_allocs = (C.float)(x.Ffrequency), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(cfFrequency_allocs)

	var clWaveform_allocs *cgoAllocMap
	ref7ebaa3d2.lWaveform, clWaveform_allocs = (C.DWORD)(x.Lwaveform), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(clWaveform_allocs)

	var cfDelay_allocs *cgoAllocMap
	ref7ebaa3d2.fDelay, cfDelay_allocs = (C.float)(x.Fdelay), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(cfDelay_allocs)

	var clPhase_allocs *cgoAllocMap
	ref7ebaa3d2.lPhase, clPhase_allocs = (C.DWORD)(x.Lphase), cgoAllocsUnknown
	allocs7ebaa3d2.Borrow(clPhase_allocs)

	x.ref7ebaa3d2 = ref7ebaa3d2
	x.allocs7ebaa3d2 = allocs7ebaa3d2
	return ref7ebaa3d2, allocs7ebaa3d2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Flanger) PassValue() (C.BASS_DX8_FLANGER, *cgoAllocMap) {
	if x.ref7ebaa3d2 != nil {
		return *x.ref7ebaa3d2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Flanger) Deref() {
	if x.ref7ebaa3d2 == nil {
		return
	}
	x.Fwetdrymix = (float32)(x.ref7ebaa3d2.fWetDryMix)
	x.Fdepth = (float32)(x.ref7ebaa3d2.fDepth)
	x.Ffeedback = (float32)(x.ref7ebaa3d2.fFeedback)
	x.Ffrequency = (float32)(x.ref7ebaa3d2.fFrequency)
	x.Lwaveform = (uint32)(x.ref7ebaa3d2.lWaveform)
	x.Fdelay = (float32)(x.ref7ebaa3d2.fDelay)
	x.Lphase = (uint32)(x.ref7ebaa3d2.lPhase)
}

// allocBassDx8GargleMemory allocates memory for type C.BASS_DX8_GARGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8GargleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8GargleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8GargleValue = unsafe.Sizeof([1]C.BASS_DX8_GARGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Gargle) Ref() *C.BASS_DX8_GARGLE {
	if x == nil {
		return nil
	}
	return x.ref99f01258
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Gargle) Free() {
	if x != nil && x.allocs99f01258 != nil {
		x.allocs99f01258.(*cgoAllocMap).Free()
		x.ref99f01258 = nil
	}
}

// NewBassDx8GargleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8GargleRef(ref unsafe.Pointer) *BassDx8Gargle {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Gargle)
	obj.ref99f01258 = (*C.BASS_DX8_GARGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Gargle) PassRef() (*C.BASS_DX8_GARGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref99f01258 != nil {
		return x.ref99f01258, nil
	}
	mem99f01258 := allocBassDx8GargleMemory(1)
	ref99f01258 := (*C.BASS_DX8_GARGLE)(mem99f01258)
	allocs99f01258 := new(cgoAllocMap)
	allocs99f01258.Add(mem99f01258)

	var cdwRateHz_allocs *cgoAllocMap
	ref99f01258.dwRateHz, cdwRateHz_allocs = (C.DWORD)(x.Dwratehz), cgoAllocsUnknown
	allocs99f01258.Borrow(cdwRateHz_allocs)

	var cdwWaveShape_allocs *cgoAllocMap
	ref99f01258.dwWaveShape, cdwWaveShape_allocs = (C.DWORD)(x.Dwwaveshape), cgoAllocsUnknown
	allocs99f01258.Borrow(cdwWaveShape_allocs)

	x.ref99f01258 = ref99f01258
	x.allocs99f01258 = allocs99f01258
	return ref99f01258, allocs99f01258

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Gargle) PassValue() (C.BASS_DX8_GARGLE, *cgoAllocMap) {
	if x.ref99f01258 != nil {
		return *x.ref99f01258, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Gargle) Deref() {
	if x.ref99f01258 == nil {
		return
	}
	x.Dwratehz = (uint32)(x.ref99f01258.dwRateHz)
	x.Dwwaveshape = (uint32)(x.ref99f01258.dwWaveShape)
}

// allocBassDx8I3dl2reverbMemory allocates memory for type C.BASS_DX8_I3DL2REVERB in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8I3dl2reverbMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8I3dl2reverbValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8I3dl2reverbValue = unsafe.Sizeof([1]C.BASS_DX8_I3DL2REVERB{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8I3dl2reverb) Ref() *C.BASS_DX8_I3DL2REVERB {
	if x == nil {
		return nil
	}
	return x.refb993b9dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8I3dl2reverb) Free() {
	if x != nil && x.allocsb993b9dd != nil {
		x.allocsb993b9dd.(*cgoAllocMap).Free()
		x.refb993b9dd = nil
	}
}

// NewBassDx8I3dl2reverbRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8I3dl2reverbRef(ref unsafe.Pointer) *BassDx8I3dl2reverb {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8I3dl2reverb)
	obj.refb993b9dd = (*C.BASS_DX8_I3DL2REVERB)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8I3dl2reverb) PassRef() (*C.BASS_DX8_I3DL2REVERB, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb993b9dd != nil {
		return x.refb993b9dd, nil
	}
	memb993b9dd := allocBassDx8I3dl2reverbMemory(1)
	refb993b9dd := (*C.BASS_DX8_I3DL2REVERB)(memb993b9dd)
	allocsb993b9dd := new(cgoAllocMap)
	allocsb993b9dd.Add(memb993b9dd)

	var clRoom_allocs *cgoAllocMap
	refb993b9dd.lRoom, clRoom_allocs = (C.int)(x.Lroom), cgoAllocsUnknown
	allocsb993b9dd.Borrow(clRoom_allocs)

	var clRoomHF_allocs *cgoAllocMap
	refb993b9dd.lRoomHF, clRoomHF_allocs = (C.int)(x.Lroomhf), cgoAllocsUnknown
	allocsb993b9dd.Borrow(clRoomHF_allocs)

	var cflRoomRolloffFactor_allocs *cgoAllocMap
	refb993b9dd.flRoomRolloffFactor, cflRoomRolloffFactor_allocs = (C.float)(x.Flroomrollofffactor), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflRoomRolloffFactor_allocs)

	var cflDecayTime_allocs *cgoAllocMap
	refb993b9dd.flDecayTime, cflDecayTime_allocs = (C.float)(x.Fldecaytime), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflDecayTime_allocs)

	var cflDecayHFRatio_allocs *cgoAllocMap
	refb993b9dd.flDecayHFRatio, cflDecayHFRatio_allocs = (C.float)(x.Fldecayhfratio), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflDecayHFRatio_allocs)

	var clReflections_allocs *cgoAllocMap
	refb993b9dd.lReflections, clReflections_allocs = (C.int)(x.Lreflections), cgoAllocsUnknown
	allocsb993b9dd.Borrow(clReflections_allocs)

	var cflReflectionsDelay_allocs *cgoAllocMap
	refb993b9dd.flReflectionsDelay, cflReflectionsDelay_allocs = (C.float)(x.Flreflectionsdelay), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflReflectionsDelay_allocs)

	var clReverb_allocs *cgoAllocMap
	refb993b9dd.lReverb, clReverb_allocs = (C.int)(x.Lreverb), cgoAllocsUnknown
	allocsb993b9dd.Borrow(clReverb_allocs)

	var cflReverbDelay_allocs *cgoAllocMap
	refb993b9dd.flReverbDelay, cflReverbDelay_allocs = (C.float)(x.Flreverbdelay), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflReverbDelay_allocs)

	var cflDiffusion_allocs *cgoAllocMap
	refb993b9dd.flDiffusion, cflDiffusion_allocs = (C.float)(x.Fldiffusion), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflDiffusion_allocs)

	var cflDensity_allocs *cgoAllocMap
	refb993b9dd.flDensity, cflDensity_allocs = (C.float)(x.Fldensity), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflDensity_allocs)

	var cflHFReference_allocs *cgoAllocMap
	refb993b9dd.flHFReference, cflHFReference_allocs = (C.float)(x.Flhfreference), cgoAllocsUnknown
	allocsb993b9dd.Borrow(cflHFReference_allocs)

	x.refb993b9dd = refb993b9dd
	x.allocsb993b9dd = allocsb993b9dd
	return refb993b9dd, allocsb993b9dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8I3dl2reverb) PassValue() (C.BASS_DX8_I3DL2REVERB, *cgoAllocMap) {
	if x.refb993b9dd != nil {
		return *x.refb993b9dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8I3dl2reverb) Deref() {
	if x.refb993b9dd == nil {
		return
	}
	x.Lroom = (int32)(x.refb993b9dd.lRoom)
	x.Lroomhf = (int32)(x.refb993b9dd.lRoomHF)
	x.Flroomrollofffactor = (float32)(x.refb993b9dd.flRoomRolloffFactor)
	x.Fldecaytime = (float32)(x.refb993b9dd.flDecayTime)
	x.Fldecayhfratio = (float32)(x.refb993b9dd.flDecayHFRatio)
	x.Lreflections = (int32)(x.refb993b9dd.lReflections)
	x.Flreflectionsdelay = (float32)(x.refb993b9dd.flReflectionsDelay)
	x.Lreverb = (int32)(x.refb993b9dd.lReverb)
	x.Flreverbdelay = (float32)(x.refb993b9dd.flReverbDelay)
	x.Fldiffusion = (float32)(x.refb993b9dd.flDiffusion)
	x.Fldensity = (float32)(x.refb993b9dd.flDensity)
	x.Flhfreference = (float32)(x.refb993b9dd.flHFReference)
}

// allocBassDx8ParameqMemory allocates memory for type C.BASS_DX8_PARAMEQ in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8ParameqMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8ParameqValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8ParameqValue = unsafe.Sizeof([1]C.BASS_DX8_PARAMEQ{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Parameq) Ref() *C.BASS_DX8_PARAMEQ {
	if x == nil {
		return nil
	}
	return x.ref2d973090
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Parameq) Free() {
	if x != nil && x.allocs2d973090 != nil {
		x.allocs2d973090.(*cgoAllocMap).Free()
		x.ref2d973090 = nil
	}
}

// NewBassDx8ParameqRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8ParameqRef(ref unsafe.Pointer) *BassDx8Parameq {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Parameq)
	obj.ref2d973090 = (*C.BASS_DX8_PARAMEQ)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Parameq) PassRef() (*C.BASS_DX8_PARAMEQ, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2d973090 != nil {
		return x.ref2d973090, nil
	}
	mem2d973090 := allocBassDx8ParameqMemory(1)
	ref2d973090 := (*C.BASS_DX8_PARAMEQ)(mem2d973090)
	allocs2d973090 := new(cgoAllocMap)
	allocs2d973090.Add(mem2d973090)

	var cfCenter_allocs *cgoAllocMap
	ref2d973090.fCenter, cfCenter_allocs = (C.float)(x.Fcenter), cgoAllocsUnknown
	allocs2d973090.Borrow(cfCenter_allocs)

	var cfBandwidth_allocs *cgoAllocMap
	ref2d973090.fBandwidth, cfBandwidth_allocs = (C.float)(x.Fbandwidth), cgoAllocsUnknown
	allocs2d973090.Borrow(cfBandwidth_allocs)

	var cfGain_allocs *cgoAllocMap
	ref2d973090.fGain, cfGain_allocs = (C.float)(x.Fgain), cgoAllocsUnknown
	allocs2d973090.Borrow(cfGain_allocs)

	x.ref2d973090 = ref2d973090
	x.allocs2d973090 = allocs2d973090
	return ref2d973090, allocs2d973090

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Parameq) PassValue() (C.BASS_DX8_PARAMEQ, *cgoAllocMap) {
	if x.ref2d973090 != nil {
		return *x.ref2d973090, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Parameq) Deref() {
	if x.ref2d973090 == nil {
		return
	}
	x.Fcenter = (float32)(x.ref2d973090.fCenter)
	x.Fbandwidth = (float32)(x.ref2d973090.fBandwidth)
	x.Fgain = (float32)(x.ref2d973090.fGain)
}

// allocBassDx8ReverbMemory allocates memory for type C.BASS_DX8_REVERB in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassDx8ReverbMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassDx8ReverbValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassDx8ReverbValue = unsafe.Sizeof([1]C.BASS_DX8_REVERB{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassDx8Reverb) Ref() *C.BASS_DX8_REVERB {
	if x == nil {
		return nil
	}
	return x.reff9a8cef5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassDx8Reverb) Free() {
	if x != nil && x.allocsf9a8cef5 != nil {
		x.allocsf9a8cef5.(*cgoAllocMap).Free()
		x.reff9a8cef5 = nil
	}
}

// NewBassDx8ReverbRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassDx8ReverbRef(ref unsafe.Pointer) *BassDx8Reverb {
	if ref == nil {
		return nil
	}
	obj := new(BassDx8Reverb)
	obj.reff9a8cef5 = (*C.BASS_DX8_REVERB)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassDx8Reverb) PassRef() (*C.BASS_DX8_REVERB, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff9a8cef5 != nil {
		return x.reff9a8cef5, nil
	}
	memf9a8cef5 := allocBassDx8ReverbMemory(1)
	reff9a8cef5 := (*C.BASS_DX8_REVERB)(memf9a8cef5)
	allocsf9a8cef5 := new(cgoAllocMap)
	allocsf9a8cef5.Add(memf9a8cef5)

	var cfInGain_allocs *cgoAllocMap
	reff9a8cef5.fInGain, cfInGain_allocs = (C.float)(x.Fingain), cgoAllocsUnknown
	allocsf9a8cef5.Borrow(cfInGain_allocs)

	var cfReverbMix_allocs *cgoAllocMap
	reff9a8cef5.fReverbMix, cfReverbMix_allocs = (C.float)(x.Freverbmix), cgoAllocsUnknown
	allocsf9a8cef5.Borrow(cfReverbMix_allocs)

	var cfReverbTime_allocs *cgoAllocMap
	reff9a8cef5.fReverbTime, cfReverbTime_allocs = (C.float)(x.Freverbtime), cgoAllocsUnknown
	allocsf9a8cef5.Borrow(cfReverbTime_allocs)

	var cfHighFreqRTRatio_allocs *cgoAllocMap
	reff9a8cef5.fHighFreqRTRatio, cfHighFreqRTRatio_allocs = (C.float)(x.Fhighfreqrtratio), cgoAllocsUnknown
	allocsf9a8cef5.Borrow(cfHighFreqRTRatio_allocs)

	x.reff9a8cef5 = reff9a8cef5
	x.allocsf9a8cef5 = allocsf9a8cef5
	return reff9a8cef5, allocsf9a8cef5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassDx8Reverb) PassValue() (C.BASS_DX8_REVERB, *cgoAllocMap) {
	if x.reff9a8cef5 != nil {
		return *x.reff9a8cef5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassDx8Reverb) Deref() {
	if x.reff9a8cef5 == nil {
		return
	}
	x.Fingain = (float32)(x.reff9a8cef5.fInGain)
	x.Freverbmix = (float32)(x.reff9a8cef5.fReverbMix)
	x.Freverbtime = (float32)(x.reff9a8cef5.fReverbTime)
	x.Fhighfreqrtratio = (float32)(x.reff9a8cef5.fHighFreqRTRatio)
}

// allocBassFxVolumeParamMemory allocates memory for type C.BASS_FX_VOLUME_PARAM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassFxVolumeParamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassFxVolumeParamValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassFxVolumeParamValue = unsafe.Sizeof([1]C.BASS_FX_VOLUME_PARAM{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassFxVolumeParam) Ref() *C.BASS_FX_VOLUME_PARAM {
	if x == nil {
		return nil
	}
	return x.ref7f7ccf78
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassFxVolumeParam) Free() {
	if x != nil && x.allocs7f7ccf78 != nil {
		x.allocs7f7ccf78.(*cgoAllocMap).Free()
		x.ref7f7ccf78 = nil
	}
}

// NewBassFxVolumeParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassFxVolumeParamRef(ref unsafe.Pointer) *BassFxVolumeParam {
	if ref == nil {
		return nil
	}
	obj := new(BassFxVolumeParam)
	obj.ref7f7ccf78 = (*C.BASS_FX_VOLUME_PARAM)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassFxVolumeParam) PassRef() (*C.BASS_FX_VOLUME_PARAM, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f7ccf78 != nil {
		return x.ref7f7ccf78, nil
	}
	mem7f7ccf78 := allocBassFxVolumeParamMemory(1)
	ref7f7ccf78 := (*C.BASS_FX_VOLUME_PARAM)(mem7f7ccf78)
	allocs7f7ccf78 := new(cgoAllocMap)
	allocs7f7ccf78.Add(mem7f7ccf78)

	var cfTarget_allocs *cgoAllocMap
	ref7f7ccf78.fTarget, cfTarget_allocs = (C.float)(x.Ftarget), cgoAllocsUnknown
	allocs7f7ccf78.Borrow(cfTarget_allocs)

	var cfCurrent_allocs *cgoAllocMap
	ref7f7ccf78.fCurrent, cfCurrent_allocs = (C.float)(x.Fcurrent), cgoAllocsUnknown
	allocs7f7ccf78.Borrow(cfCurrent_allocs)

	var cfTime_allocs *cgoAllocMap
	ref7f7ccf78.fTime, cfTime_allocs = (C.float)(x.Ftime), cgoAllocsUnknown
	allocs7f7ccf78.Borrow(cfTime_allocs)

	var clCurve_allocs *cgoAllocMap
	ref7f7ccf78.lCurve, clCurve_allocs = (C.DWORD)(x.Lcurve), cgoAllocsUnknown
	allocs7f7ccf78.Borrow(clCurve_allocs)

	x.ref7f7ccf78 = ref7f7ccf78
	x.allocs7f7ccf78 = allocs7f7ccf78
	return ref7f7ccf78, allocs7f7ccf78

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassFxVolumeParam) PassValue() (C.BASS_FX_VOLUME_PARAM, *cgoAllocMap) {
	if x.ref7f7ccf78 != nil {
		return *x.ref7f7ccf78, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassFxVolumeParam) Deref() {
	if x.ref7f7ccf78 == nil {
		return
	}
	x.Ftarget = (float32)(x.ref7f7ccf78.fTarget)
	x.Fcurrent = (float32)(x.ref7f7ccf78.fCurrent)
	x.Ftime = (float32)(x.ref7f7ccf78.fTime)
	x.Lcurve = (uint32)(x.ref7f7ccf78.lCurve)
}

func (x Iosnotifyproc) PassRef() (ref *C.IOSNOTIFYPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if iosnotifyprocC7638A61Func == nil {
		iosnotifyprocC7638A61Func = x
	}
	return (*C.IOSNOTIFYPROC)(C.IOSNOTIFYPROC_c7638a61), nil
}

func NewIosnotifyprocRef(ref unsafe.Pointer) *Iosnotifyproc {
	return (*Iosnotifyproc)(ref)
}

//export iosnotifyprocC7638A61
func iosnotifyprocC7638A61(cstatus C.DWORD) {
	if iosnotifyprocC7638A61Func != nil {
		statusc7638a61 := (uint32)(cstatus)
		iosnotifyprocC7638A61Func(statusc7638a61)
		return
	}
	panic("callback func has not been set (race?)")
}

var iosnotifyprocC7638A61Func Iosnotifyproc

func (x Encodeproc) PassRef() (ref *C.ENCODEPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if encodeprocA0C39546Func == nil {
		encodeprocA0C39546Func = x
	}
	return (*C.ENCODEPROC)(C.ENCODEPROC_a0c39546), nil
}

func NewEncodeprocRef(ref unsafe.Pointer) *Encodeproc {
	return (*Encodeproc)(ref)
}

//export encodeprocA0C39546
func encodeprocA0C39546(chandle C.HENCODE, cchannel C.DWORD, cbuffer unsafe.Pointer, clength C.DWORD, cuser unsafe.Pointer) {
	if encodeprocA0C39546Func != nil {
		handlea0c39546 := (Hencode)(chandle)
		channela0c39546 := (uint32)(cchannel)
		buffera0c39546 := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		lengtha0c39546 := (uint32)(clength)
		usera0c39546 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		encodeprocA0C39546Func(handlea0c39546, channela0c39546, buffera0c39546, lengtha0c39546, usera0c39546)
		return
	}
	panic("callback func has not been set (race?)")
}

var encodeprocA0C39546Func Encodeproc

func (x Encodeprocex) PassRef() (ref *C.ENCODEPROCEX, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if encodeprocex8F215FF2Func == nil {
		encodeprocex8F215FF2Func = x
	}
	return (*C.ENCODEPROCEX)(C.ENCODEPROCEX_8f215ff2), nil
}

func NewEncodeprocexRef(ref unsafe.Pointer) *Encodeprocex {
	return (*Encodeprocex)(ref)
}

//export encodeprocex8F215FF2
func encodeprocex8F215FF2(chandle C.HENCODE, cchannel C.DWORD, cbuffer unsafe.Pointer, clength C.DWORD, coffset C.QWORD, cuser unsafe.Pointer) {
	if encodeprocex8F215FF2Func != nil {
		handle8f215ff2 := (Hencode)(chandle)
		channel8f215ff2 := (uint32)(cchannel)
		buffer8f215ff2 := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		length8f215ff2 := (uint32)(clength)
		offset8f215ff2 := (uint64)(coffset)
		user8f215ff2 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		encodeprocex8F215FF2Func(handle8f215ff2, channel8f215ff2, buffer8f215ff2, length8f215ff2, offset8f215ff2, user8f215ff2)
		return
	}
	panic("callback func has not been set (race?)")
}

var encodeprocex8F215FF2Func Encodeprocex

func (x Encoderproc) PassRef() (ref *C.ENCODERPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if encoderprocCA4A3C53Func == nil {
		encoderprocCA4A3C53Func = x
	}
	return (*C.ENCODERPROC)(C.ENCODERPROC_ca4a3c53), nil
}

func NewEncoderprocRef(ref unsafe.Pointer) *Encoderproc {
	return (*Encoderproc)(ref)
}

//export encoderprocCA4A3C53
func encoderprocCA4A3C53(chandle C.HENCODE, cchannel C.DWORD, cbuffer unsafe.Pointer, clength C.DWORD, cmaxout C.DWORD, cuser unsafe.Pointer) C.DWORD {
	if encoderprocCA4A3C53Func != nil {
		handleca4a3c53 := (Hencode)(chandle)
		channelca4a3c53 := (uint32)(cchannel)
		bufferca4a3c53 := (unsafe.Pointer)(unsafe.Pointer(cbuffer))
		lengthca4a3c53 := (uint32)(clength)
		maxoutca4a3c53 := (uint32)(cmaxout)
		userca4a3c53 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		retca4a3c53 := encoderprocCA4A3C53Func(handleca4a3c53, channelca4a3c53, bufferca4a3c53, lengthca4a3c53, maxoutca4a3c53, userca4a3c53)
		ret, _ := (C.DWORD)(retca4a3c53), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var encoderprocCA4A3C53Func Encoderproc

func (x Encodeclientproc) PassRef() (ref *C.ENCODECLIENTPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if encodeclientproc541D704Func == nil {
		encodeclientproc541D704Func = x
	}
	return (*C.ENCODECLIENTPROC)(C.ENCODECLIENTPROC_541d704), nil
}

func NewEncodeclientprocRef(ref unsafe.Pointer) *Encodeclientproc {
	return (*Encodeclientproc)(ref)
}

//export encodeclientproc541D704
func encodeclientproc541D704(chandle C.HENCODE, cconnect C.BOOL, cclient *C.char, cheaders *C.char, cuser unsafe.Pointer) C.BOOL {
	if encodeclientproc541D704Func != nil {
		handle541d704 := (Hencode)(chandle)
		connect541d704 := (int32)(cconnect)
		client541d704 := packPCharString(cclient)
		headers541d704 := (*byte)(unsafe.Pointer(cheaders))
		user541d704 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		ret541d704 := encodeclientproc541D704Func(handle541d704, connect541d704, client541d704, headers541d704, user541d704)
		ret, _ := (C.BOOL)(ret541d704), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var encodeclientproc541D704Func Encodeclientproc

func (x Encodenotifyproc) PassRef() (ref *C.ENCODENOTIFYPROC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if encodenotifyprocFDEF6823Func == nil {
		encodenotifyprocFDEF6823Func = x
	}
	return (*C.ENCODENOTIFYPROC)(C.ENCODENOTIFYPROC_fdef6823), nil
}

func NewEncodenotifyprocRef(ref unsafe.Pointer) *Encodenotifyproc {
	return (*Encodenotifyproc)(ref)
}

//export encodenotifyprocFDEF6823
func encodenotifyprocFDEF6823(chandle C.HENCODE, cstatus C.DWORD, cuser unsafe.Pointer) {
	if encodenotifyprocFDEF6823Func != nil {
		handlefdef6823 := (Hencode)(chandle)
		statusfdef6823 := (uint32)(cstatus)
		userfdef6823 := (unsafe.Pointer)(unsafe.Pointer(cuser))
		encodenotifyprocFDEF6823Func(handlefdef6823, statusfdef6823, userfdef6823)
		return
	}
	panic("callback func has not been set (race?)")
}

var encodenotifyprocFDEF6823Func Encodenotifyproc

// allocBassMixerNodeMemory allocates memory for type C.BASS_MIXER_NODE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBassMixerNodeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBassMixerNodeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBassMixerNodeValue = unsafe.Sizeof([1]C.BASS_MIXER_NODE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BassMixerNode) Ref() *C.BASS_MIXER_NODE {
	if x == nil {
		return nil
	}
	return x.ref9dd585c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BassMixerNode) Free() {
	if x != nil && x.allocs9dd585c7 != nil {
		x.allocs9dd585c7.(*cgoAllocMap).Free()
		x.ref9dd585c7 = nil
	}
}

// NewBassMixerNodeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBassMixerNodeRef(ref unsafe.Pointer) *BassMixerNode {
	if ref == nil {
		return nil
	}
	obj := new(BassMixerNode)
	obj.ref9dd585c7 = (*C.BASS_MIXER_NODE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BassMixerNode) PassRef() (*C.BASS_MIXER_NODE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9dd585c7 != nil {
		return x.ref9dd585c7, nil
	}
	mem9dd585c7 := allocBassMixerNodeMemory(1)
	ref9dd585c7 := (*C.BASS_MIXER_NODE)(mem9dd585c7)
	allocs9dd585c7 := new(cgoAllocMap)
	allocs9dd585c7.Add(mem9dd585c7)

	var cpos_allocs *cgoAllocMap
	ref9dd585c7.pos, cpos_allocs = (C.QWORD)(x.Pos), cgoAllocsUnknown
	allocs9dd585c7.Borrow(cpos_allocs)

	var cvalue_allocs *cgoAllocMap
	ref9dd585c7.value, cvalue_allocs = (C.float)(x.Value), cgoAllocsUnknown
	allocs9dd585c7.Borrow(cvalue_allocs)

	x.ref9dd585c7 = ref9dd585c7
	x.allocs9dd585c7 = allocs9dd585c7
	return ref9dd585c7, allocs9dd585c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BassMixerNode) PassValue() (C.BASS_MIXER_NODE, *cgoAllocMap) {
	if x.ref9dd585c7 != nil {
		return *x.ref9dd585c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BassMixerNode) Deref() {
	if x.ref9dd585c7 == nil {
		return
	}
	x.Pos = (uint64)(x.ref9dd585c7.pos)
	x.Value = (float32)(x.ref9dd585c7.value)
}

// copyPFloatBytes copies the data from Go slice as *C.float.
func copyPFloatBytes(slice *sliceHeader) (*C.float, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFloatValue) * slice.Len,
		Cap:  int(sizeOfFloatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.float)(mem0), allocs
}

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})
